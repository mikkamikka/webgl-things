
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>viz</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        color: #ffffff;
        font-family:Monospace;
        font-size:13px;
        text-align:center;
        font-weight: bold;

        background-color: #000000;
        margin: 0px;
        overflow: hidden;
      }
      #gui {
        right: 0;
        position: absolute;
        top: 0;
        z-index:100;
      }
			#video_buttons {
				position: absolute;
        top: 50%; transform: translateY(-50%);
        left: 0px;
        width: 170px;
        z-index: 100;
			}
      video {
				width: 100%;
				display:block;
				padding: 4px;
      }
    </style>
  </head>
  <body>

    <div id="container"></div>

		<div id="video_buttons">
	    <video autoplay accessKey="0" >
	      <source src="image/waves3.ogg" type='video/ogg; codecs="theora, vorbis"'>
	    </video>
	    <video accessKey="1">
	      <source src="image/waves4.ogg" type='video/ogg; codecs="theora, vorbis"'>
	    </video>
	    <video accessKey="2">
	      <source src="image/waves2.ogg" type='video/ogg; codecs="theora, vorbis"'>
	    </video>
			<video accessKey="3">
	      <source src="image/waves5.ogg" type='video/ogg; codecs="theora, vorbis"'>
	    </video>
			<video accessKey="4">
	      <source src="image/waves6.ogg" type='video/ogg; codecs="theora, vorbis"'>
	    </video>

		</div>


    <div id="gui"></div>

    <script src="libs/three.js"></script>
    <script src="libs/Detector.js"></script>
    <script src="libs/stats.min.js"></script>
    <script src="libs/dat.gui.min.js"></script>
    <script src="libs/controls/OrbitControls.js"></script>

    <script id="vertexShader" type="x-shader/x-vertex">

    varying vec2 vUv;
    varying vec3 vNormal;
    varying vec3 vReflect;
    varying float ao;
    uniform float time;
    uniform vec2 resolution;

    uniform sampler2D displacementMap;
    uniform float displacementScale;
    uniform float displacementBias;

    uniform float normalsRatio;
    uniform float lookupRadius;
    uniform float mode;

    vec3 transformDirection( in vec3 normal, in mat4 matrix ) {

      return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );

    }

    void main() {

      vec3 transformed = position;
      vec3 transformedNormal = normalMatrix * normal;
      vNormal = normalize( transformedNormal );
      //vNormal = normal;
      vUv = uv;

			float mean = ( texture2D( displacementMap, uv ).x + texture2D( displacementMap, uv ).y + texture2D( displacementMap, uv ).z ) / 3.0;

      transformed += normal * ( mean * displacementScale + displacementBias );

      vec3 tut = texture2D( displacementMap, uv ).xyz;

      float aspect = resolution.x/resolution.y;
      float dx = lookupRadius / resolution.x;
      float dy = dx * aspect;

      vec4 dy1 = texture2D( displacementMap, uv + vec2( 0.0, dy ) );
      vec4 dy2 = texture2D( displacementMap, uv + vec2( 0.0, -dy ) );

      vec4 dx1 = texture2D( displacementMap, uv + vec2( dx, 0.0 ) );
      vec4 dx2 = texture2D( displacementMap, uv + vec2( -dx, 0.0 ) );

      float difX = 0.0;
      float difY = 0.0;

      if (mode > 0.5){

				vec4 d5 = texture2D( displacementMap, uv + vec2( dx, dy ) );
	      vec4 d6 = texture2D( displacementMap, uv + vec2( -dx, -dy ) );
	      vec4 d7 = texture2D( displacementMap, uv + vec2( dx, -dy ) );
	      vec4 d8 = texture2D( displacementMap, uv + vec2( -dx, dy ) );

        difX = ( dx1.x - dx2.x + d5.x - d6.x + d7.x - d8.x ) / 3.0;
        difY = ( dy1.y - dy2.y + d5.y - d6.y + d7.y - d8.y ) / 3.0;
      }
      else{

        difX = dx1.x - dx2.x;
        difY = dy1.y - dy2.y;

      }


      vec3 modifiedNormal = normalize( normal + normalsRatio * vec3( difX, difY, 0.0 ) );

      vec3 worldNormal = normalize( -1.0 * mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * modifiedNormal );

      vec3 cameraToVertex = normalize( transformed.xyz - cameraPosition );

      //#ifdef ENVMAP_MODE_REFLECTION

        vReflect = reflect( cameraToVertex, worldNormal );

      //#else

        //vReflect = refract( cameraToVertex, worldNormal, 0.5 );

      //#endif

      gl_Position = projectionMatrix * modelViewMatrix * vec4( transformed, 1.0 );

    }

    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">

    varying vec2 vUv;
    varying vec3 vNormal;
    varying vec3 vReflect;
    varying float ao;
    uniform sampler2D envMap;
    uniform float time;

    void main() {

      #ifdef DOUBLE_SIDED
        float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );
      #else
        float flipNormal = 1.0;
      #endif

      vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( vReflect, 0.0 )).xyz + vec3(0.0,0.0,1.0));
      vec3 color = texture2D( envMap, reflectView.xy * 0.5 + 0.5 ).xyz;

      gl_FragColor = vec4( color, 1.0 );

    }

    </script>

    <script>

      if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

      var container, stats;

      var camera, scene, renderer;
      var object, edges, material;
      var video = [], video_texture, textureSphere;

      var params = {
        displacementScale: 45,
        normalsRatio: 4,
        lookupRadius: 1,
        mode: 0
      }

      init();
      animate();

      gui = new dat.GUI();
      //gui.remember(params);
      //var f0 = gui.addFolder('Params');
      gui.add(params, 'displacementScale').min(1).max(200).step(1).onChange(
        function(value){
          material.uniforms[ 'displacementScale' ].value = value;
        } );
      gui.add(params, 'normalsRatio').min(1).max(30).step(0.1).onChange(
        function(value){
          material.uniforms[ 'normalsRatio' ].value = value;
        } );
      gui.add(params, 'lookupRadius').min(0.1).max(10).step(0.1).onChange(
        function(value){
          material.uniforms[ 'lookupRadius' ].value = value;
        } );
      gui.add(params, 'mode').min(0).max(1).step(1).onChange(
        function(value){
          material.uniforms[ 'mode' ].value = value;
        } );
        gui.close();


      function createMy( radius ) {

        var geometry = new THREE.IcosahedronGeometry( radius, 7 );

        // material

        material = new THREE.ShaderMaterial( {

          uniforms: {

            "displacementMap" : { type: "t", value: video_texture },
            "displacementScale" : { type: "f", value: 60 },
            "displacementBias" : { type: "f", value: 0 },

            //"normalMap" : { type: "t", value: video_texture },
            //"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) },

            "resolution" : { type: "v2", value: new THREE.Vector2( 300, 300 ) },
            "normalsRatio" : { type: "f", value: 10.0 },
            "lookupRadius" : { type: "f", value: 1.0 },
            "mode" : { type: "f", value: 0.0 },

            envMap: { type: "t", value: textureSphere },
            time: { type: "f", value: 0 }

          },
          vertexShader: document.getElementById( 'vertexShader' ).textContent,
          fragmentShader: document.getElementById( 'fragmentShader' ).textContent,


          //side: THREE.DoubleSide,
          //shading: THREE.FlatShading

        } );

        var mesh = new THREE.Mesh( geometry, material );
        return mesh;
      }

      function createSphere (radius) {

        //var geometry = new THREE.SphereGeometry( radius, 320, 160 );
        var geometry = new THREE.IcosahedronGeometry( radius, 7 );
        var material = new THREE.MeshPhongMaterial( {
          color: 0xaaaaaa,
          specular: 0x333333,
          shininess: 15,
          emissive: 0x000000,

          metal: true,

          //polygonOffset: true,
          //polygonOffsetFactor: 100,
          //polygonOffsetUnits: 10,

          //side: THREE.DoubleSide,

          //transparent: true,
          //opacity: 0.99,

          //map: THREE.ImageUtils.loadTexture( "image/pluto.jpg" ),
          //map: video_texture,
          //bumpMap: video_texture,
          //lightMap:
          //aoMap:

          //emissiveMap: THREE.ImageUtils.loadTexture( "image/roid_displ4.jpg" ),
          //emissiveMap: video_texture,

          //specularMap:
          //alphaMap:

          //envMap: textureSphere,
          //reflectivity: 0.99,
          //refractionRatio: 0.99,

          //normalMap: THREE.ImageUtils.loadTexture( "image/noise_ao.jpg" ),
          normalMap: video_texture,
          normalScale: new THREE.Vector2( .5, .5),

          //displacementMap: THREE.ImageUtils.loadTexture( "image/roid_displ4.jpg" ),
          displacementMap: video_texture,
          displacementScale: 30.0,

          //shading: THREE.SmoothShading

          //morphTargets: false

          //wireframe: true,
          //wireframeLinewidth: 4,
          //wireframeLinecap:'round',
          //wireframeLinejoin: 'round'


        } );
        var mesh = new THREE.Mesh( geometry, material );

        // var mesh = new THREE.Object3D();
        // mesh.add( new THREE.LineSegments(
        //   new THREE.Geometry(),
        //   new THREE.LineBasicMaterial({  color: 0xffffff,  transparent: true, opacity: 0.5  })
        // ));
        // mesh.add( new THREE.Mesh(
        //   new THREE.Geometry(),
        //   new THREE.MeshPhongMaterial({  color: 0x156289,  emissive: 0x072534,  side: THREE.DoubleSide,  shading: THREE.FlatShading })
        // ));

        return mesh;

      }


      function init() {

        container = document.getElementById( 'container' );

        camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.z = 500;

        scene = new THREE.Scene();

        var ambientLight = new THREE.AmbientLight( 0x666666 );
        scene.add( ambientLight );

        var lights = [];
        lights[0] = new THREE.PointLight( 0xffffff, 1, 0 );
        lights[1] = new THREE.PointLight( 0xffffff, 1, 0 );
        lights[2] = new THREE.PointLight( 0xffffff, 1, 0 );

        lights[0].position.set( -300, 600, 200 );
        lights[1].position.set( 100, 600, 100 );
        lights[2].position.set( -100, -600, -400 );

        scene.add( lights[0] );
        scene.add( lights[1] );
        scene.add( lights[2] );


        // geometry

				var btns = document.getElementById('video_buttons').children;

				for (var i=0; i < btns.length; i++){

					video[i] = btns[i];
					video[i].playbackRate = 1.0;

//					console.log(typeof video[i].loop );




					video[i].addEventListener("ended", function(args) {

						var ix = args.target.accessKey;
						//video[ix].currentTime = 0;
						//video[ix].play();
						video[ix].load();
						//console.log("replay");

					});

					video[i].addEventListener("click", function(args) {

						var other_btns = args.target.parentElement.children;
						var ix = args.target.accessKey;
						for (var i=0; i < other_btns.length; i++){
							if (i != ix) video[i].pause();
						}
						video[ix].paused ? video[ix].play() : video[ix].pause();

						video_texture = new THREE.VideoTexture( video[ix] );
						video_texture.minFilter = THREE.LinearFilter;
						video_texture.magFilter = THREE.LinearFilter;
						video_texture.format = THREE.RGBFormat;

						material.uniforms[ 'displacementMap' ].value = video_texture;

					});

				}

        video_texture = new THREE.VideoTexture( video[0] );
        video_texture.minFilter = THREE.LinearFilter;
        video_texture.magFilter = THREE.LinearFilter;
        video_texture.format = THREE.RGBFormat;

        textureSphere = THREE.ImageUtils.loadTexture( "image/pluto.jpg" );
        textureSphere.mapping = THREE.SphericalReflectionMapping;
        //textureSphere.mapping = THREE.EquirectangularRefractionMapping;

        //object = createSphere(60);

        object = createMy(60);

        scene.add( object );

        renderer = new THREE.WebGLRenderer({
            antialias: true
        });

        //renderer.gammaInput = true;
        //renderer.gammaOutput = true;
        //renderer.physicallyBasedShading = true;

        renderer.setClearColor( 0x101010 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        var orbit = new THREE.OrbitControls( camera, renderer.domElement );

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild( stats.domElement );

        window.addEventListener( 'resize', onWindowResize, false );

      }

      function createVideoTexture(){
        var canPlayMp4  = document.createElement('video').canPlayType('video/mp4') !== '' ? true : false;
        var canPlayOgg  = document.createElement('video').canPlayType('video/ogg') !== '' ? true : false;
        if( canPlayMp4 ){
          var url  = 'image/sintel.mp4';
        }else if( canPlayOgg ){
          var url  = 'image/sintel.ogv';
        }else  alert('cant play mp4 or ogv');

        // create the videoTexture
        video_texture= new THREE.VideoTexture(url);
        video  = video_texture.video;
        //updateFcts.push(function(delta, now){
        //  videoTexture.update(delta, now)
        //});
      }

      function onWindowResize( event ) {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      //

      function animate() {

        requestAnimationFrame( animate );

        render();
        stats.update();

      }

      var start = Date.now();

      function render() {

        var time = performance.now();

        object.rotation.y = time * 0.000005;

        renderer.render( scene, camera );

      }

    </script>

  </body>
</html>
