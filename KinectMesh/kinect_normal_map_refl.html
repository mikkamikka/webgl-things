
<!DOCTYPE html>
<html lang="en">
<head>
  <title>Kinect displacement and normal mapping</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
    body {
      color: #ffffff;
      font-family:Monospace;
      font-size:13px;
      text-align:center;
      font-weight: normal;

      background-color: #000000;
      margin: 0px;
      overflow: hidden;
    }
    #info {
      position: absolute;
      bottom: 0px; width: 100%;
      padding: 5px;
    }
    #gui_container {
      right: 0;
      position: absolute;
      top: 0;
      z-index:100;
    }
    #gui {
    //right: 0;
    //position: absolute;
    //top: 0;
    //z-index:100;
    }
    #checkboxes {
      right: 0;
      position: absolute;
      top: 50%;
      width: 220px;
      z-index:100;
    }
    #video_buttons {
      position: absolute;
      top: 50%; transform: translateY(-50%);
      left: 0px;
      width: 170px;
      z-index: 100;
    }
    video {
      width: 100%;
      display:block;
      padding: 4px;
    }
  </style>
</head>
<body>

<div id="info">
  Kinect depth height map + normals estimation from texture + reflection mapping <br/>
  Created by <a href="http://twitter.com/blackmika" target="_blank">@blackmika</a>.
</div>

<div id="container"></div>


<div id="video_buttons">
  <div style="font-weight: normal">Click to play/pause</div>
  <div id="buttons">
    <video autoplay accessKey="0">
      <source src="media/1.ogg" type='video/ogg; codecs="theora, vorbis"'>
    </video>
    <!--video accessKey="3">
      <source src="../image/waves5.ogg" type='video/ogg; codecs="theora, vorbis"'>
    </video>
    <video accessKey="4">
      <source src="../image/waves6.ogg" type='video/ogg; codecs="theora, vorbis"'>
    </video-->
  </div>
</div>

<div id="gui_container">
  <div id="gui"></div>
</div>
<div id="checkboxes" align="left">
  <input type="checkbox" id="cbox1"  onclick='setRefractionMode();'>
  <label for="cbox1">Refraction</label><br>
  <input type="checkbox" id="cbox2" value="" onclick='setNormalMode2();'>
  <label for="cbox2">Normals mode 2</label><br>
  <input type="checkbox" id="cbox3" value="" onclick='setSmoothTexture();'>
  <label for="cbox3">Use Smooth Texture</label>
</div>

<script src="../r78/three.js"></script>
<script src="../libs/Detector.js"></script>
<script src="../libs/stats.min.js"></script>
<script src="../libs/dat.gui.min.js"></script>
<script src="../libs/controls/OrbitControls.js"></script>

<script id="smooth_vs" type="x-shader/x-vertex">
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }

    </script>

<script id="smooth_fs" type="x-shader/x-fragment">

    uniform sampler2D colorMap;
    varying vec2 vUv;
    uniform vec2 resolution;
    uniform float fWidth;
    uniform float fHeight;

    vec4 getTexel( vec2 p )
    {
        p = p * resolution + 0.5;

        vec2 i = floor(p);
        vec2 f = p - i;
        f = f*f*f*(f*(f*6.0-15.0)+10.0);
        p = i + f;

        p = (p - 0.5)/resolution;
        return texture2D( colorMap, p );
    }

    float BellFunc( float x )
    {
        float f = ( x / 2.0 ) * 1.5; // Converting -2 to +2 to -1.5 to +1.5
        if( f > -1.5 && f < -0.5 )
        {
            return( 0.5 * pow(f + 1.5, 2.0));
        }
        else if( f > -0.5 && f < 0.5 )
        {
            return 3.0 / 4.0 - ( f * f );
        }
        else if( ( f > 0.5 && f < 1.5 ) )
        {
            return( 0.5 * pow(f - 1.5, 2.0));
        }
        return 0.0;
    }

    vec4 BiCubic( sampler2D textureSampler, vec2 TexCoord )
    {
        float texelSizeX = 1.0 / fWidth; //size of one texel
        float texelSizeY = 1.0 / fHeight; //size of one texel
        vec4 nSum = vec4( 0.0, 0.0, 0.0, 0.0 );
        vec4 nDenom = vec4( 0.0, 0.0, 0.0, 0.0 );
        float a = fract( TexCoord.x * fWidth ); // get the decimal part
        float b = fract( TexCoord.y * fHeight ); // get the decimal part

        int nX = int(TexCoord.x * fWidth);
        int nY = int(TexCoord.y * fHeight);
        vec2 TexCoord1 = vec2( float(nX) / fWidth + 0.5 / fWidth,
                               float(nY) / fHeight + 0.5 / fHeight );
        for( int m = -1; m <=2; m++ )
        {
            for( int n =-1; n<= 2; n++)
            {
                vec4 vecData = texture2D(textureSampler, TexCoord1 + vec2( texelSizeX * float(m), texelSizeY * float(n)));
                float f  = BellFunc( float( m ) - a );
                vec4 vecCooef1 = vec4( f, f, f, f );
                float f1 = BellFunc( -( float( n ) - b ) );
                vec4 vecCoeef2 = vec4( f1, f1, f1, f1 );
                nSum = nSum + ( vecData * vecCoeef2 * vecCooef1  );
                nDenom = nDenom + (( vecCoeef2 * vecCooef1 ));
            }
        }
        return nSum / nDenom;
    }

    void main() {

	  //vec3 color = texture2D( colorMap, vUv ).xyz;

      //gl_FragColor = getTexel(vUv);

      gl_FragColor = BiCubic( colorMap, vUv );

    }


    </script>

<script id="vertexShader" type="x-shader/x-vertex">

    varying vec2 vUv;
    varying vec3 vNormal;
    varying vec3 vReflect;
    varying float ao;
    uniform float time;
    //uniform float weight;
    uniform vec2 resolution;

    uniform sampler2D displacementMap;
    uniform float displacementScale;
    uniform float displacementBias;

    uniform float normalsRatio;
    uniform float lookupRadius;
    uniform float mode;
    varying float drawMode;
    uniform float refractionMode;
    uniform float normalMode2;


    void main() {

      vec3 transformedNormal = normalMatrix * normal;
      vNormal = normalize( transformedNormal );
      vUv = uv;

      float aspect = resolution.x/resolution.y;
      float dx = lookupRadius / resolution.x;
      float dy = dx * aspect;

      vec4 dy1 = texture2D( displacementMap, uv + vec2( 0.0, dy ) );
      vec4 dy2 = texture2D( displacementMap, uv + vec2( 0.0, -dy ) );

      vec4 dx1 = texture2D( displacementMap, uv + vec2( dx, 0.0 ) );
      vec4 dx2 = texture2D( displacementMap, uv + vec2( -dx, 0.0 ) );

      float difX = 0.0;
      float difY = 0.0;

      if (mode > 0.5){

        vec4 d5 = texture2D( displacementMap, uv + vec2( dx, dy ) );
        vec4 d6 = texture2D( displacementMap, uv + vec2( -dx, -dy ) );
        vec4 d7 = texture2D( displacementMap, uv + vec2( dx, -dy ) );
        vec4 d8 = texture2D( displacementMap, uv + vec2( -dx, dy ) );

        difX = ( dx1.x - dx2.x + d5.x - d6.x + d7.x - d8.x ) / 3.0;
        difY = ( dy1.y - dy2.y + d5.y - d6.y + d7.y - d8.y ) / 3.0;
      }
      else{

        difX = dx1.x - dx2.x;
        difY = dy1.y - dy2.y;

      }

      //cut off background plane
      if ( texture2D( displacementMap, uv ).x < 0.01 ) drawMode = 0.0;
      else drawMode = 1.0;
      //additional cut off
      if (dx1.x == 0.0 || dx2.x==0.0 || dy1.x==0.0 || dy2.x==0.0) drawMode = 0.0;

      float mean = texture2D( displacementMap, uv ).x;
      float smooth_mean = ( texture2D( displacementMap, uv ).x + dx1.x + dx2.x + dy1.x + dy2.x ) / 5.0;

      vec3 deltaNormal = vec3(0.0);

      if (normalMode2 > 0.0){
        deltaNormal = ( 1.0 - mean ) * vec3( difX, difY, 0.0 );
      } else {
        deltaNormal = vec3( difX, difY, 0.0 );
      }

      vec3 modifiedNormal = normalize( normal - refractionMode * normalsRatio * deltaNormal );

	  vec3 transformedPos = position + normal * ( smooth_mean * displacementScale + displacementBias );

	  vec3 worldNormal = normalize( -1.0 * mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * modifiedNormal );

      vec3 cameraToVertex = normalize( transformedPos - cameraPosition );

      vReflect = reflect( cameraToVertex, worldNormal );

      gl_Position = projectionMatrix * modelViewMatrix * vec4( transformedPos, 1.0 );


    }

    </script>

<script id="fragmentShader" type="x-shader/x-fragment">

    varying vec2 vUv;
    varying vec3 vNormal;
    varying vec3 vReflect;
    varying float ao;
    uniform sampler2D envMap;
    uniform float time;
    varying float drawMode;
    float PI = 3.1415926535897932;

    void main() {

      float yaw = .5 - atan( vReflect.z, - vReflect.x ) / ( 2.0 * PI );
	  float pitch = .5 + asin( vReflect.y ) / PI;
	  vec2 pos = vec2( yaw, pitch );
	  vec3 color = texture2D( envMap, pos ).xyz;

      gl_FragColor = vec4( color, 1.0 );

      if (drawMode == 0.0) discard;

    }

    </script>

<script>

  if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

  var container, stats;

  var camera, scene, renderer, controls;
  var object, edges, material, material2;
  var video = [], video_texture, textureSphere;

  var depthWidth = 512, depthHeight = 424, smoothTexture;
  var textureCamera, textureScene, textureRenderer, textureMesh, textureMaterial, textureGeometry;
  var smoothWidth, smoothHeight;

  var params = {
    displacementScale: 240,
    normalsRatio: 4.5,
    lookupRadius: 4.5,
    mode: 1,
    weight: 1.0,
    refraction: setRefractionMode,
    normalMode2: setNormalMode2
  }

  var useSmoothTexture = false;

  function setSmoothTexture() {

    useSmoothTexture = ! useSmoothTexture;

    if ( useSmoothTexture )
      material.uniforms[ 'displacementMap' ].value = smoothTexture.texture;
    else
      material.uniforms[ 'displacementMap' ].value = video_texture;

  }

  var refractionMode = 1;

  function setRefractionMode() {

    refractionMode = -1 * refractionMode;
    material.uniforms[ 'refractionMode' ].value = refractionMode;

  }

  var normalMode2 = -1;

  function setNormalMode2() {

    normalMode2 = -1 * normalMode2;
    material.uniforms[ 'normalMode2' ].value = normalMode2;

  }

  init();
  animate();

  var gui = new dat.GUI();
  //gui.remember(params);
  //var f0 = gui.addFolder('Params');
  gui.add(params, 'displacementScale').min(1).max(600).step(1).onChange(
          function(value){
            material.uniforms[ 'displacementScale' ].value = value;
          } );
  gui.add(params, 'normalsRatio').min(1).max(30).step(0.1).onChange(
          function(value){
            material.uniforms[ 'normalsRatio' ].value = value;
          } );
  gui.add(params, 'lookupRadius').min(0.1).max(10).step(0.1).onChange(
          function(value){
            material.uniforms[ 'lookupRadius' ].value = value;
          } );
  gui.add(params, 'mode').min(0).max(1).step(1).onChange(
          function(value){
            material.uniforms[ 'mode' ].value = value;
          } );
  //gui.add(params, 'refraction');
  //gui.add(params, 'normalMode2');

  gui.close();

  function setSmoothingPass(){

    // new render-to-texture scene
    textureScene = new THREE.Scene();

    // you may need to modify these parameters
    var renderTargetParams = {
      minFilter:THREE.LinearFilter,
      stencilBuffer:false,
      depthBuffer:false
    };


    smoothWidth = depthWidth * 2;
    smoothHeight = depthHeight * 2;

    // create buffer
    smoothTexture = new THREE.WebGLRenderTarget( smoothWidth, smoothHeight, renderTargetParams );

    // custom RTT materials
    myUniforms = {
      colorMap: { type: "t", value: video_texture },
      resolution: { type: "v2", value: new THREE.Vector2( smoothWidth, smoothHeight )},
      fWidth: { type: "f", value: depthWidth },
      fHeight: { type: "f", value: depthHeight }
    };
    textureMaterial = new THREE.ShaderMaterial({
      uniforms: myUniforms,
      vertexShader: document.getElementById( 'smooth_vs' ).textContent,
      fragmentShader: document.getElementById( 'smooth_fs' ).textContent
    });

    // Setup render-to-texture scene
    textureCamera = new THREE.OrthographicCamera( smoothWidth / - 2,
            smoothWidth / 2,
            smoothHeight / 2,
            smoothHeight / - 2, -10000, 10000 );

    textureGeometry = new THREE.PlaneBufferGeometry( smoothWidth, smoothHeight );
    textureMesh = new THREE.Mesh( textureGeometry, textureMaterial );
    textureMesh.position.z = -100;

    textureScene.add( textureMesh );

  }

  function createThing() {

    var geometry = new THREE.PlaneBufferGeometry( 512, 424, 512, 424 );

    material = new THREE.ShaderMaterial( {

      uniforms: {

        "displacementMap" : { type: "t", value: video_texture },
        "displacementScale" : { type: "f", value: params.displacementScale },
        "displacementBias" : { type: "f", value: 0 },

        //"normalMap" : { type: "t", value: video_texture },
        //"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) },

        "resolution" : { type: "v2", value: new THREE.Vector2( depthWidth, depthHeight ) },
        "normalsRatio" : { type: "f", value: params.normalsRatio },
        "lookupRadius" : { type: "f", value: params.lookupRadius },
        "mode" : { type: "f", value: 0.0 },
        "refractionMode" : { type: "f", value: 1.0 },
        "normalMode2" : { type: "f", value: -1.0 },
        //"weight" : { type: "f", value: 1.0 },

        envMap: { type: "t", value: textureSphere },
        time: { type: "f", value: 0 }

      },
      vertexShader: document.getElementById( 'vertexShader' ).textContent,
      fragmentShader: document.getElementById( 'fragmentShader' ).textContent,

    } );

    var mesh = new THREE.Mesh( geometry, material );
    return mesh;

  }

  function addLights() {

    var ambientLight = new THREE.AmbientLight( 0x666666 );
    scene.add( ambientLight );

    var lights = [];
    lights[0] = new THREE.PointLight( 0xffffff, 0.5, 0 );
    lights[1] = new THREE.PointLight( 0xffffff, 0.5, 0 );
    lights[2] = new THREE.PointLight( 0xffffff, 0.5, 0 );

    lights[0].position.set( -300, 600, 200 );
    lights[1].position.set( 100, 600, 100 );
    lights[2].position.set( -100, -300, 1000 );

    scene.add( lights[0] );
    scene.add( lights[1] );
    scene.add( lights[2] );

  }

  function init() {

    container = document.getElementById( 'container' );

    camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );
    camera.position.z = 800;

    scene = new THREE.Scene();

    //addLights();

    var btns = document.getElementById('buttons').children;

    for (var i=0; i < btns.length; i++){

      video[i] = btns[i];
      video[i].playbackRate = 1.0;

      video[i].addEventListener("ended", function(args) {

        var ix = args.target.accessKey;
        //video[ix].currentTime = 0;
        //video[ix].play();
        video[ix].load();
        video[ix].play();

      });

      video[i].addEventListener("click", function(args) {

        var other_btns = args.target.parentElement.children;
        var ix = args.target.accessKey;
        for (var i=0; i < other_btns.length; i++){
          if (i != ix) video[i].pause();
        }
        video[ix].paused ? video[ix].play() : video[ix].pause();

        video_texture = new THREE.VideoTexture( video[ix] );
        video_texture.minFilter = THREE.LinearFilter;
        video_texture.magFilter = THREE.LinearFilter;
        video_texture.format = THREE.RGBFormat;

        material.uniforms[ 'displacementMap' ].value = video_texture;
        //material2.displacementMap = video_texture;

      });

    }

    video_texture = new THREE.VideoTexture( video[0] );
    video_texture.minFilter = THREE.LinearFilter;
    video_texture.magFilter = THREE.LinearFilter;
    video_texture.format = THREE.RGBFormat;
    //video[1].play();

    textureSphere = THREE.ImageUtils.loadTexture( "../image/pai_pano_sm.jpg" );
    //textureSphere.mapping = THREE.SphericalReflectionMapping;
    //textureSphere.mapping = THREE.EquirectangularRefractionMapping;

    var sphere = new THREE.Mesh( new THREE.SphereGeometry( 1000, 60, 60 ),
            new THREE.MeshBasicMaterial( { map: textureSphere } ) );
    sphere.scale.x = -1;
    sphere.doubleSided = true;
    //scene.add( sphere );

    setSmoothingPass();

    object = createThing();

    scene.add( object );

    renderer = new THREE.WebGLRenderer({
      //antialias: true
    });

    renderer.setClearColor( 0x101010 );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    container.appendChild( renderer.domElement );

    controls = new THREE.OrbitControls( camera, renderer.domElement );
    controls.maxDistance = 1300;

    stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.top = '0px';
    container.appendChild( stats.domElement );

    window.addEventListener( 'resize', onWindowResize, false );

  }

  function onWindowResize( event ) {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

  }

  function animate() {

    requestAnimationFrame( animate );

    render();
    stats.update();

  }

  var start = Date.now();

  function render() {

    //var time = performance.now();

    if (useSmoothTexture)
      renderer.render( textureScene, textureCamera, smoothTexture, true );

    renderer.render( scene, camera );

  }

</script>

</body>
</html>
