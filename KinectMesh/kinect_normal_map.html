
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Kinect displacement and normal mapping</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        color: #ffffff;
        font-family:Monospace;
        font-size:13px;
        text-align:center;
        font-weight: normal;

        background-color: #000000;
        margin: 0px;
        overflow: hidden;
      }
      #info {
        position: absolute;
        bottom: 0px; width: 100%;
        padding: 5px;
      }
      #gui {
        right: 0;
        position: absolute;
        top: 0;
        z-index:100;
      }
      #video_buttons {
        position: absolute;
        top: 50%; transform: translateY(-50%);
        left: 0px;
        width: 170px;
        z-index: 100;
      }
      video {
        width: 100%;
        display:block;
        padding: 4px;
      }
    </style>
  </head>
  <body>

    <div id="info">
      Kinect depth displacement map + normals estimation from texture <br/>
      Created by <a href="http://twitter.com/blackmika" target="_blank">@blackmika</a>.
    </div>

    <div id="container"></div>


    <div id="video_buttons">
      <div style="font-weight: normal">Click to play/pause</div>
      <div id="buttons">
        <video autoplay accessKey="0" >
          <source src="media/anya.ogg" type='video/ogg; codecs="theora, vorbis"'>
        </video>
        <!--video accessKey="2">
          <source src="image/waves2.ogg" type='video/ogg; codecs="theora, vorbis"'>
        </video>
        <video accessKey="3">
          <source src="image/waves5.ogg" type='video/ogg; codecs="theora, vorbis"'>
        </video>
        <video accessKey="4">
          <source src="image/waves6.ogg" type='video/ogg; codecs="theora, vorbis"'>
        </video-->
      </div>
    </div>


    <div id="gui"></div>

    <script src="../r78/three.js"></script>
    <script src="../libs/Detector.js"></script>
    <script src="../libs/stats.min.js"></script>
    <script src="../libs/dat.gui.min.js"></script>
    <script src="../libs/controls/OrbitControls.js"></script>

    <script id="vertexShader" type="x-shader/x-vertex">

    varying vec2 vUv;
    varying vec3 vNormal;
    varying vec3 vReflect;
    varying float ao;
    uniform float time;
    uniform vec2 resolution;

    uniform sampler2D displacementMap;
    uniform float displacementScale;
    uniform float displacementBias;

    uniform float normalsRatio;
    uniform float lookupRadius;
    uniform float mode;
    varying float drawMode;

    vec3 transformDirection( in vec3 normal, in mat4 matrix ) {

      return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );

    }

    void main() {

      vec3 transformed = position;
      vec3 transformedNormal = normalMatrix * normal;
      vNormal = normalize( transformedNormal );
      //vNormal = normal;
      vUv = uv;

      float mean = ( texture2D( displacementMap, uv ).x + texture2D( displacementMap, uv ).y + texture2D( displacementMap, uv ).z ) / 3.0;

      if ( texture2D( displacementMap, uv ).x == 0.0 ) drawMode = 0.0;
      else drawMode = 1.0;

      transformed += normal * ( mean * displacementScale + displacementBias );

      //vec3 tut = texture2D( displacementMap, uv ).xyz;

      float aspect = resolution.x/resolution.y;
      float dx = lookupRadius / resolution.x;
      float dy = dx * aspect;

      vec4 dy1 = texture2D( displacementMap, uv + vec2( 0.0, dy ) );
      vec4 dy2 = texture2D( displacementMap, uv + vec2( 0.0, -dy ) );

      vec4 dx1 = texture2D( displacementMap, uv + vec2( dx, 0.0 ) );
      vec4 dx2 = texture2D( displacementMap, uv + vec2( -dx, 0.0 ) );

      float difX = 0.0;
      float difY = 0.0;

      if (mode > 0.5){

        vec4 d5 = texture2D( displacementMap, uv + vec2( dx, dy ) );
        vec4 d6 = texture2D( displacementMap, uv + vec2( -dx, -dy ) );
        vec4 d7 = texture2D( displacementMap, uv + vec2( dx, -dy ) );
        vec4 d8 = texture2D( displacementMap, uv + vec2( -dx, dy ) );

        difX = ( dx1.x - dx2.x + d5.x - d6.x + d7.x - d8.x ) / 3.0;
        difY = ( dy1.y - dy2.y + d5.y - d6.y + d7.y - d8.y ) / 3.0;
      }
      else{

        difX = dx1.x - dx2.x;
        difY = dy1.y - dy2.y;

      }

      if (dx1.x == 0.0 || dx2.x==0.0 || dy1.x==0.0 || dy2.x==0.0) drawMode = 0.0;

      vec3 modifiedNormal = normalize( normal + normalsRatio * vec3( difX, difY, 0.0 ) );

      vec3 worldNormal = normalize( -1.0 * mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * modifiedNormal );

      vec3 cameraToVertex = normalize( transformed.xyz - cameraPosition );

      vReflect = reflect( cameraToVertex, worldNormal );

      gl_Position = projectionMatrix * modelViewMatrix * vec4( transformed, 1.0 );

    }

    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">

    varying vec2 vUv;
    varying vec3 vNormal;
    varying vec3 vReflect;
    varying float ao;
    uniform sampler2D envMap;
    uniform float time;
    varying float drawMode;

    void main() {

      float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );

      vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( vReflect, 0.0 )).xyz + vec3(0.0,0.0,1.0));
      vec3 color = texture2D( envMap, reflectView.xy * 0.5 + 0.5 ).xyz;

      gl_FragColor = vec4( color, 0.5 );

      if (drawMode == 0.0) discard;

    }

    </script>

    <script>

      if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

      var container, stats;

      var camera, scene, renderer, controls;
      var object, edges, material, material2;
      var video = [], video_texture, textureSphere;

      var params = {
        displacementScale: 180,
        normalsRatio: 12,
        lookupRadius: 1.7,
        mode: 0
      }

      init();
      animate();

      gui = new dat.GUI();
      //gui.remember(params);
      //var f0 = gui.addFolder('Params');
      gui.add(params, 'displacementScale').min(1).max(600).step(1).onChange(
        function(value){
          material.uniforms[ 'displacementScale' ].value = value;
        } );
      gui.add(params, 'normalsRatio').min(1).max(30).step(0.1).onChange(
        function(value){
          material.uniforms[ 'normalsRatio' ].value = value;
        } );
      gui.add(params, 'lookupRadius').min(0.1).max(10).step(0.1).onChange(
        function(value){
          material.uniforms[ 'lookupRadius' ].value = value;
        } );
      gui.add(params, 'mode').min(0).max(1).step(1).onChange(
        function(value){
          material.uniforms[ 'mode' ].value = value;
        } );
        gui.close();


      function createThing( radius ) {

        var geometry = new THREE.PlaneBufferGeometry(512,424, 1024, 848);

        material = new THREE.ShaderMaterial( {

          uniforms: {

            "displacementMap" : { type: "t", value: video_texture },
            "displacementScale" : { type: "f", value: params.displacementScale },
            "displacementBias" : { type: "f", value: 0 },

            //"normalMap" : { type: "t", value: video_texture },
            //"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) },

            "resolution" : { type: "v2", value: new THREE.Vector2( 300, 300 ) },
            "normalsRatio" : { type: "f", value: params.normalsRatio },
            "lookupRadius" : { type: "f", value: params.lookupRadius },
            "mode" : { type: "f", value: 0.0 },

            envMap: { type: "t", value: textureSphere },
            time: { type: "f", value: 0 }

          },
          vertexShader: document.getElementById( 'vertexShader' ).textContent,
          fragmentShader: document.getElementById( 'fragmentShader' ).textContent,

          //side: THREE.DoubleSide,
          //shading: THREE.FlatShading

        } );

        material2 = new THREE.MeshPhongMaterial({
          color: 0x004488,
          displacementMap: video_texture,
          displacementScale: 120,
          shading: THREE.FlatShading

        })

        var mesh = new THREE.Mesh( geometry, material );
        return mesh;

      }

      function addLights() {

        var ambientLight = new THREE.AmbientLight( 0x666666 );
        scene.add( ambientLight );

        var lights = [];
        lights[0] = new THREE.PointLight( 0xffffff, 1, 0 );
        lights[1] = new THREE.PointLight( 0xffffff, 1, 0 );
        lights[2] = new THREE.PointLight( 0xffffff, 1, 0 );

        lights[0].position.set( -300, 600, 200 );
        lights[1].position.set( 100, 600, 100 );
        lights[2].position.set( -100, -300, 1000 );

        scene.add( lights[0] );
        scene.add( lights[1] );
        scene.add( lights[2] );

      }

      function init() {

        container = document.getElementById( 'container' );

        camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.z = 500;

        scene = new THREE.Scene();

        addLights();

        var btns = document.getElementById('buttons').children;

        for (var i=0; i < btns.length; i++){

            video[i] = btns[i];
            video[i].playbackRate = 1.0;

            video[i].addEventListener("ended", function(args) {

              var ix = args.target.accessKey;
              //video[ix].currentTime = 0;
              //video[ix].play();
              video[ix].load();

            });

          video[i].addEventListener("click", function(args) {

            var other_btns = args.target.parentElement.children;
            var ix = args.target.accessKey;
            for (var i=0; i < other_btns.length; i++){
              if (i != ix) video[i].pause();
            }
            video[ix].paused ? video[ix].play() : video[ix].pause();

            video_texture = new THREE.VideoTexture( video[ix] );
            video_texture.minFilter = THREE.LinearFilter;
            video_texture.magFilter = THREE.LinearFilter;
            video_texture.format = THREE.RGBFormat;

            material.uniforms[ 'displacementMap' ].value = video_texture;
            material2.displacementMap = video_texture;

          });

        }

        video_texture = new THREE.VideoTexture( video[0] );
        video_texture.minFilter = THREE.LinearFilter;
        video_texture.magFilter = THREE.LinearFilter;
        video_texture.format = THREE.RGBFormat;
        //video[1].play();

        textureSphere = THREE.ImageUtils.loadTexture( "../image/planet.jpg" );
        textureSphere.mapping = THREE.SphericalReflectionMapping;
        //textureSphere.mapping = THREE.EquirectangularRefractionMapping;

        object = createThing(60);

        //object.rotation.y = Math.PI / 2;

        scene.add( object );


        renderer = new THREE.WebGLRenderer({
            antialias: true
        });

        renderer.setClearColor( 0x101010 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.maxDistance = 500;

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild( stats.domElement );

        window.addEventListener( 'resize', onWindowResize, false );

      }

      function onWindowResize( event ) {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      function animate() {

        requestAnimationFrame( animate );

        render();
        stats.update();

      }

      var start = Date.now();

      function render() {

        //var time = performance.now();

        object.rotation.y += 0.00009;

        renderer.render( scene, camera );

      }

    </script>

  </body>
</html>
