<!DOCTYPE html>
<html lang="en">
<head>
    <title>logo</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>

<body style="margin: 0; background: #334CFF;">

<div id="logo"></div>


<script src="js/three.min.js"></script>

<script src="js/Detector.js"></script>

<script src="js/Cloth.js"></script>

<script type="x-shader/x-fragment" id="fragmentShaderDepth">

			#include <packing>

			uniform sampler2D texture;
			varying vec2 vUV;

			void main() {

				vec4 pixel = texture2D( texture, vUV );

				if ( pixel.a < 0.5 ) discard;

				gl_FragData[ 0 ] = packDepthToRGBA( gl_FragCoord.z );

			}
		</script>

<script type="x-shader/x-vertex" id="vertexShaderDepth">

			varying vec2 vUV;

			void main() {

				vUV = 0.75 * uv;

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

<script>

    /* testing cloth simulation */

    var pinsFormation = [];
    pins = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
    pins = [ 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120 ];

//    for ( var pl = cloth.particles.length, i = pl-30; i < pl; i ++ ) {
//
//        pins.push( i );
//
//    }
    pinsFormation.push( pins );

    if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

    var container, stats;
    var camera, scene, renderer;

    var clothGeometry, clothTexture;
    var sphere;
    var object;
    var mouse = new THREE.Vector2(), INTERSECTED;

    init();
    animate();

    function getBase64Image(img) {
        // Create an empty canvas element
        var canvas = document.createElement("canvas");
        canvas.width = img.width;
        canvas.height = img.height;

        // Copy the image contents to the canvas
        var ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);

        // Get the data-URL formatted image
        // Firefox supports PNG and JPEG. You could check img.src to
        // guess the original format, but be aware the using "image/jpg"
        // will re-encode the image.
        var dataURL = canvas.toDataURL("image/png");

        return dataURL;

        //return dataURL.replace(/^data:image\/(png|jpg);base64,/, "");
    }

    function init() {

        container = document.getElementById( 'logo' );

        // scene

        scene = new THREE.Scene();
        //scene.fog = new THREE.Fog( 0xcce0ff, 500, 10000 );

        // camera

        camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 10000 );
        camera.position.x = 0;
        camera.position.y = 0;
        camera.position.z = 500;
        scene.add( camera );

        // lights

        var light, materials;

        scene.add( new THREE.AmbientLight( 0x666666 ) );

        light = new THREE.DirectionalLight( 0xdfebff, 1.75 );
        light.position.set( 50, 200, 100 );
        light.position.multiplyScalar( 1.3 );

        scene.add( light );

        // cloth material

        var loader = new THREE.TextureLoader();
        clothTexture = loader.load( 'images/logo.png' );
        //clothTexture.wrapS = clothTexture.wrapT = THREE.RepeatWrapping;
        //clothTexture.anisotropy = 16;

        var clothMaterial = new THREE.MeshBasicMaterial( {
            //specular: 0x030303,
            map: clothTexture,
            side: THREE.DoubleSide,
            alphaTest: 0.5
        } );

        // cloth geometry
        clothGeometry = new THREE.ParametricGeometry( clothFunction, cloth.w, cloth.h );
        clothGeometry.dynamic = true;

        var uniforms = { texture:  { value: clothTexture } };
        var vertexShader = document.getElementById( 'vertexShaderDepth' ).textContent;
        var fragmentShader = document.getElementById( 'fragmentShaderDepth' ).textContent;

        // cloth mesh

        object = new THREE.Mesh( clothGeometry, clothMaterial );
        object.position.set( 0, -240, 0 );
        object.scale.x = 1.1;
        //object.rotation.y = Math.PI;
        //object.rotation.z = Math.PI;
        //object.castShadow = true;
        scene.add( object );

//        object.customDepthMaterial = new THREE.ShaderMaterial( {
//            uniforms: uniforms,
//            vertexShader: vertexShader,
//            fragmentShader: fragmentShader,
//            side: THREE.DoubleSide
//        } );

        // sphere

        var ballGeo = new THREE.SphereGeometry( ballSize, 20, 20 );
        var ballMaterial = new THREE.MeshPhongMaterial( { color: 0xaaaaaa } );

        sphere = new THREE.Mesh( ballGeo, ballMaterial );
        //sphere.castShadow = true;
        //sphere.receiveShadow = true;
        scene.add( sphere );

        // renderer

        renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        //renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setSize( 200, 300 );
        //renderer.setClearColor( 0xffffff );


        container.appendChild( renderer.domElement );

        renderer.gammaInput = true;
        renderer.gammaOutput = true;

        //renderer.shadowMap.enabled = true;
        document.addEventListener( 'mousemove', onDocumentMouseMove, false )

        sphere.visible = !true;

    }

    function onDocumentMouseMove( event ) {

        event.preventDefault();

        mouse.x = ( event.clientX / renderer.domElement.width ) * 2 - 1;
        mouse.y = - ( event.clientY / renderer.domElement.height ) * 2 + 1;

    }

    function animate() {

        requestAnimationFrame( animate );

        var time = Date.now();

        windStrength = Math.cos( time / 20000 ) * 1;
        windForce.set( Math.sin( time / 10000 ), Math.cos( time / 10000 ), Math.sin( time / 200 ) ).normalize().multiplyScalar( windStrength );

        windForce.z *= 2;

        simulate( time );
        render();

    }

    function render() {

        var p = cloth.particles;

        for ( var i = 0, il = p.length; i < il; i ++ ) {

            clothGeometry.vertices[ i ].copy( p[ i ].position );

        }

        clothGeometry.computeFaceNormals();
        clothGeometry.computeVertexNormals();

        clothGeometry.normalsNeedUpdate = true;
        clothGeometry.verticesNeedUpdate = true;

        sphere.position.copy( ballPosition );

        camera.lookAt( scene.position );

        renderer.render( scene, camera );

    }

</script>
</body>
</html>
