<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - shader [Monjori]</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            color: #ffffff;
            font-family:Monospace;
            font-size:13px;
            text-align:center;
            font-weight: bold;
            background-color: #eeeeee;
            margin: 0px;
            //overflow: hidden;
        }
        #info {
            position: absolute;
            top: 0px; width: 100%;
            padding: 5px;
        }
        a {
            color: #ffffff;
        }
        #oldie a { color:#da0 }
    </style>
</head>
<body>

<div id="container"></div>
<div id="info">

<script src="../r78/three.js"></script>

<script src="../libs/Detector.js"></script>
<script src="../libs/stats.min.js"></script>
<script src="../libs/controls/OrbitControls.js"></script>

    <script src="conv_layer.js"></script>
    <script src="pool_layer.js"></script>
    <script src="fc_layer.js"></script>
    <script src="softmax_layer.js"></script>
    <script src="regression_layer.js"></script>

<script id="vertexShader" type="x-shader/x-vertex">

precision highp float;
precision highp int;
uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
    varying vec2 vUv;
    void main()	{
        vUv = uv;
        gl_Position = vec4( position, 1.0 );

        //vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
        //gl_Position = projectionMatrix * mvPosition;
    }
</script>



<script id="fragmentShader_noise" type="x-shader/x-fragment">

precision highp float;
precision highp int;

varying vec2 vUv;

uniform vec2 rand_c;
uniform float mode;

vec2 hash( vec2 p ) {
    p = vec2( dot(p,vec2(127.1,311.7)),
    dot(p,vec2(269.5,183.3)) );

    return -1.0 + 2.0*fract(sin(p)*43758.5453123);
}

float noise( in vec2 p ){

    const float K1 = 0.366025404; // (sqrt(3)-1)/2;
    const float K2 = 0.211324865; // (3-sqrt(3))/6;

    vec2 i = floor( p + (p.x+p.y)*K1 );

    vec2 a = p - i + (i.x+i.y)*K2;
    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));
    vec2 b = a - o + K2;
    vec2 c = a - 1.0 + 2.0*K2;

    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );

    vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));

    return dot( n, vec3(70.0) );
}

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

// -----------------------------------------------
void main(){

    vec2 uv = vUv;

    uv *= 2.0;
    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );
    float r  = 0.5000*noise( uv ); uv = m*uv;
    r += 0.5500*noise( uv ); uv = m*uv;
    //f += 0.1250*noise( uv ); uv = m*uv;
    //f += 0.0625*noise( uv ); uv = m*uv;
    m = mat2( 1.5,  1.2, -1.5,  1.6 );
    float g  = 0.8000*noise( uv ); uv = m*uv;
    m = mat2( 0.6,  2.2, 1.2,  2.1 );
    float b  = 0.5000*noise( uv ); uv = m*uv;
    b += 0.3800*noise( uv ); uv = m*uv;


    //r *= smoothstep( 0.0, 0.005, abs(p.x-0.6) );

    r = rand( uv + rand_c ) - 0.25;
    g = rand( uv + hash( rand_c ) ) - 0.25;
    b = rand( uv + rand( rand_c ) ) - 0.25;

    //r = rand( rand_c );
    //g = rand( rand_c );
   // b = rand( rand_c );


    gl_FragColor = vec4( r*1., g*1., b*1., 1.0 );
    if (mode>0.0) gl_FragColor = vec4( r, r, r, 1.0 );
}
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
precision highp float;
precision highp int;
uniform vec2 resolution;
uniform sampler2D texture;
varying vec2 vUv;
void main()	{
    gl_FragColor = texture2D( texture, vUv );
}
</script>

<script id="fragmentShader_copy" type="x-shader/x-fragment">
precision highp float;
precision highp int;
uniform sampler2D texture;
varying vec2 vUv;
void main()	{
    gl_FragColor = texture2D( texture, vUv );
}
</script>

<script id="fragmentShader_relu" type="x-shader/x-fragment">

precision highp float;
precision highp int;

uniform vec2 resolution;
uniform float mode;
uniform sampler2D in_texture;  //inputs (x)
uniform sampler2D texture;     //weights and biases
uniform sampler2D back_texture; // w deltas
varying vec2 vUv;
void main()	{

    if (mode==0.0){  //forward

        float w_r = texture2D( texture, vUv ).x;
        float w_g = texture2D( texture, vUv ).y;
        float w_b = texture2D( texture, vUv ).z;

        float in_x = texture2D( in_texture, vUv ).x;
        float in_y = texture2D( in_texture, vUv ).y;
        float in_z = texture2D( in_texture, vUv ).z;

        float product_r = in_x * w_r;
        float product_g = in_y * w_g;
        float product_b = in_z * w_b;

        //float product_r = dot(in_x , w_r);
        //float product_g = dot(in_y , w_g);
        //float product_b = dot(in_z , w_b);

        gl_FragColor = vec4( product_r, product_g, product_b, 1.0 );

    }
    else{  //backward

        float w = texture2D( texture, vUv ).x;
        float dw = texture2D( back_texture, vUv ).z;

        float newWeight = w + 0.02 * dw;

        gl_FragColor = vec4( newWeight, texture2D( texture, vUv ).yz, 1.0 );

    }
}
</script>

<script id="vertexShader_sum" type="x-shader/x-vertex">

precision highp float;
precision highp int;
uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;

varying vec2 vUv;

varying vec4 color_lod;
uniform sampler2D texture;

void main()	{
    vUv = uv;
    gl_Position = vec4( position, 1.0 );

    vec2 lp = vec2( 0.0, 0.0 );
    float d = 0.5;
    color_lod = texture2DLod( texture, vec2( 0.0, 0.0 ), 10.0 );
    color_lod += texture2DLod( texture, vec2( d, 0.0 ), 10.0 );
    color_lod += texture2DLod( texture, vec2( 0.0, d ), 10.0 );
    color_lod += texture2DLod( texture, vec2( d, d ), 10.0 );
    color_lod = texture2DLod( texture, uv, 7.0 );
}
</script>

<script id="fragmentShader_sum" type="x-shader/x-fragment">

#extension GL_EXT_shader_texture_lod : enable
#extension GL_OES_standard_derivatives : enable

precision highp float;
precision highp int;

uniform vec2 resolution;
//uniform vec3 bias;

uniform sampler2D texture;     //weights and biases

varying vec4 color_lod;
varying vec2 vUv;

void main()	{

    //float sum = 0.0;

    //vec4 mip = texture2D(texture, vec2(-0.5,-0.5), 7.0 );
    //mip += texture2D(texture, vec2(0.5,0.5), 7.0 );
    //mip += texture2D(texture, vec2(-0.5,0.5), 7.0 );
    //mip += texture2D(texture, vec2(0.5,-0.5), 7.0 );
    //mip = mip * 0.25;

    //float act_r = max( 0.5, mip.x + bias.x );
    //float act_g = max( 0.5, mip.y + bias.y );
    //float act_b = max( 0.5, mip.z + bias.z );

    //if ( vUv.x < 0.5 && vUv.y > 0.5 )
    //    gl_FragColor = vec4( mip.x, 0.0, 0.0, 0.0 );

    //    else if ( vUv.x > 0.5 && vUv.y > 0.5 )
    //        gl_FragColor = vec4( 0.0, mip.y, 0.0, 0.0 );

    //        else if ( vUv.x < 0.5 && vUv.y < 0.5 )
    //            gl_FragColor = vec4( 0.0, 0.0, mip.z, 0.0 );

    //            else if ( vUv.x > 0.5 && vUv.y < 0.5 )
    //                gl_FragColor = mip;

    //if ( vUv.x > 0.75 && vUv.y < 0.25 )
        //gl_FragColor = vec4( act_r, act_g, act_b, 1.0 );

    //gl_FragColor = texture2D(texture, vUv, 7.0 );

    //gl_FragColor = color_lod;

    float k = 1.0 / 8.0;

    gl_FragColor = texture2DGradEXT(texture, mod(vUv, vec2(k, k)) ,
                                  dFdx( vUv ), dFdy( vUv ) );

    //gl_FragColor = texture2DGradEXT(texture, mod(vUv, vec2(k, k)) ,
                                  //vec2(0.0,0.0), vec2(0.0,0.0) );

    //gl_FragColor =  texture2DLodEXT(texture, vUv, 0.5);

}
</script>

<script id="fragmentShader_out" type="x-shader/x-fragment">

precision highp float;
precision highp int;

uniform vec2 resolution;
uniform float time;
uniform sampler2D in_texture;  // activations
uniform sampler2D texture;     // sample
varying vec2 vUv;
uniform vec3 bias;
void main()	{

    //float activation = texture2D( in_texture, vUv ).z;
    //float y = texture2D( texture, vUv ).x;   //sample
    //float dw = activation - y;// - activation;

    gl_FragColor = texture2D( in_texture, vUv );

    vec4 sum = vec4(0.0,0.0,0.0,1.0);

    const float uv_step = 1.0/3.0;
    const float start_uv = 1.0/3.0/2.0;

    for ( float i=start_uv; i < 1.0; i+=uv_step ){

        for ( float j=start_uv; j < 1.0; j+=uv_step ){

            vec2 coord = vec2( i , j );
            sum += texture2D( in_texture, coord );
        }
    }

    sum = sum / 9.0;

    //if ( vUv.x > 0.66 && vUv.y < 0.33 )  // debug
        gl_FragColor = vec4( sum.x, sum.y, sum.z, 1.0 );



    // activation "ReLU"

    float threshold = 0.0;

    float act_r = max( threshold, sum.x + bias.x );
    float act_g = max( threshold, sum.y + bias.y );
    float act_b = max( threshold, sum.z + bias.z );

    gl_FragColor = vec4( act_r, act_g, act_b, 1.0 );

}
</script>

<script>

    if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
    var container, stats;
    //var camera=[], scene=[],
    var renderer, controls;
    //var uniforms = [],
    var textures = [], layers = [];
    //var weightsTexture, copy_weightsTexture, bufferTexture, outputTexture;
    var firstRun = true;
    //var train = false;
    var net;


    var options = options || {};
    var learning_rate = typeof options.learning_rate !== 'undefined' ? options.learning_rate : 0.01;
    var l1_decay = typeof options.l1_decay !== 'undefined' ? options.l1_decay : 0.0;
    var l2_decay = typeof options.l2_decay !== 'undefined' ? options.l2_decay : 0.0;
    var batch_size = typeof options.batch_size !== 'undefined' ? options.batch_size : 1;
    var method = typeof options.method !== 'undefined' ? options.method : 'sgd'; // sgd/adagrad/adadelta/windowgrad/netsterov

    var momentum = typeof options.momentum !== 'undefined' ? options.momentum : 0.9;
    var ro = typeof options.ro !== 'undefined' ? options.ro : 0.95; // used in adadelta
    var eps = typeof options.eps !== 'undefined' ? options.eps : 1e-6; // used in adadelta

    var k = 0; // iteration counter
    var gsum = []; // last iteration gradients (used for momentum calculations)
    var xsum = []; // used in adadelta


    var cost_loss = 0.0;
    var l2_decay_loss = 0.0;
    var l1_decay_loss = 0.0;









    function loadTextures( callback ){

        textures[0] = new THREE.TextureLoader().load("../textures/sunflower.jpg", function(){
            //textures[0] = new THREE.TextureLoader().load("aaa.png", function(){

            textures[1] = new THREE.TextureLoader().load("noise3x48g.png", function(){

                textures[1].minFilter = THREE.NearestFilter;
                textures[1].magFilter = THREE.NearestFilter;

                textures[2] = new THREE.TextureLoader().load("../textures/andro.png", function(){

                    textures[0].format = THREE.RGBAFormat;
                    textures[0].type = THREE.FloatType;
                    textures[0].generateMipmaps = true;
                    textures[0].needsUpdate = true;

                    callback();
                });
            });
        });
    }


    init();




    function init(){

        container = document.getElementById( 'container' );

        renderer = new THREE.WebGLRenderer(
                //{alpha: true}
                { preserveDrawingBuffer: true }
        );
        renderer.setSize( 128*7, 128*20 );
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);
        renderer.autoClear = false;
        renderer.autoClearColor = false;
        // renderer.autoClearDepth = false;
        //renderer.autoClearStencil = false;
        renderer.clear();

        renderer.context.getExtension('EXT_shader_texture_lod');

        onWindowResize();
        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('keydown', onDocumentKeyDown, false);

        loadTextures( createNet );

    }

    function createNet() {


        //  ConvLayer = function( id, renderer, sx, Nfilters, input_layer, stride, pad, noise_texture )
        layers.push( new ConvLayer( 0, renderer, 3, 2, undefined, 1, 0, false ) );

        //layers.push( new ConvLayer( 1, renderer, 3, 3, layers[0], 1, 0, false ) );
        layers.push( new PoolLayer( 1, renderer, 2, layers[0], 2, 0 ) );

        layers.push( new ConvLayer( 2, renderer, 3, 4, layers[1], 1, 0, false ) );

        layers.push( new PoolLayer( 3, renderer, 2, layers[2], 2, 0 ) );

        layers.push( new ConvLayer( 4, renderer, 3, 4, layers[3], 1, 0, false ) );

        layers.push( new PoolLayer( 5, renderer, 2, layers[4], 2, 0 ) );

        layers.push( new ConvLayer( 6, renderer, 3, 4, layers[5], 1, 0, false ) );

        layers.push( new PoolLayer( 7, renderer, 2, layers[6], 2, 0 ) );

        //var FCLayer = function( id, renderer, out_depth, input_layer )
        layers.push( new FCLayer( 8, renderer, 10, layers[7] ) );

        layers.push( new RegressionLayer( 9, renderer, layers[8] ) );


        layers[0].setInputTexture( textures[0], 128 );

        for (var i=0; i< layers.length; i++) {

            layers[i].init();

        }

    }

    //function train() {

        // initialize lists for accumulators. Will only be done once on first iteration
//        if(this.gsum.length === 0 && (this.method !== 'sgd' || this.momentum > 0.0)) {
//            // only vanilla sgd doesnt need either lists
//            // momentum needs gsum
//            // adagrad needs gsum
//            // adadelta needs gsum and xsum
//            for(var i=0;i<pglist.length;i++) {
//                this.gsum.push(global.zeros(pglist[i].params.length));
//                if(this.method === 'adadelta') {
//                    this.xsum.push(global.zeros(pglist[i].params.length));
//                } else {
//                    this.xsum.push([]); // conserve memory
//                }
//            }
//        }






   // }



    function onDocumentKeyDown( event ) {

        console.log( event.keyCode );

        switch( event.keyCode ) {

            case 49:  // '1' key

                    for (var i=0; i< layers.length - 1; i++) {

                        layers[i].renderToTexture();
                        layers[i].renderToScreen();

                    }

                layers[layers.length-1].forward();
                layers[layers.length-1].backward();



                break;

            case 50:   // 2

                for (var i=layers.length - 2; i >= 0; i--) {

                    layers[i].backward();
                    layers[i].updateFilter();

                }

                break;

            case 13:   // Enter


                animate();


                break;

            case 27:   // ESC

                cancelAnimationFrame(id);

                break;
        }
    }

    var loss = { x:1, y:1, z:1 }; var limit = 0.001;
    var iter = 0;

    var fps = 60;
    var now;
    var then = Date.now();
    var interval = 1000/fps;
    var delta;
    var id;

    function animate() {

        id = requestAnimationFrame( animate );

        now = Date.now();
        delta = now - then;

        if (delta > interval) {

            then = now - (delta % interval);

            train();
        }
    }

    function train() {

        if ( loss.x > limit || loss.y > limit || loss.z > limit ) {

            for (var i=0; i< layers.length - 1; i++) {

                layers[i].renderToTexture();
                layers[i].renderToScreen();

            }

            layers[layers.length-1].forward();
            loss = layers[layers.length-1].backward();


            //layers[layers.length-2].backward();
            //layers[layers.length-2].updateFilter();

            for (var i=layers.length - 2; i >= 0; i--) {

                layers[i].backward();
                layers[i].updateFilter();

            }

            iter++;

        } else {

            cancelAnimationFrame(id);

        }

        console.log('iterations: ', iter);

    }




    function onWindowResize( event ) {
        //renderer.setSize( window.innerWidth, window.innerHeight );
        //uniforms.resolution.value.x = 512;
        //uniforms.resolution.value.y = 512;
    }

</script>

</body>
</html>