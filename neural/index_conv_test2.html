<!DOCTYPE html>
<html lang="en">
<head>
    <title>convnn tests</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            color: #ffffff;
            font-family:Monospace;
            font-size:13px;
            text-align:center;
            font-weight: bold;
            background-color: #eeeeee;
            margin: 0px;
            //overflow: hidden;
        }
        #info {
            position: absolute;
            top: 0px; width: 100%;
            padding: 5px;
        }
        a {
            color: #ffffff;
        }
        #oldie a { color:#da0 }
    </style>
</head>
<body>

<div id="container"></div>
<div id="info">

<script src="../r78/three.js"></script>

<script src="../libs/Detector.js"></script>
<script src="../libs/stats.min.js"></script>
<script src="../libs/controls/OrbitControls.js"></script>

    <script src="common.js"></script>
    <script src="conv_layer.js"></script>
    <script src="pool_layer.js"></script>
    <script src="fc_layer.js"></script>
    <script src="softmax_layer.js"></script>
    <script src="regression_layer.js"></script>

<script id="vertexShader" type="x-shader/x-vertex">

precision highp float;
precision highp int;
uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
    varying vec2 vUv;
    void main()	{
        vUv = uv;
        gl_Position = vec4( position, 1.0 );
    }
</script>

<script id="fragmentShader_noise" type="x-shader/x-fragment">

precision highp float;
precision highp int;

varying vec2 vUv;

uniform vec2 rand_c;
uniform float mode;

vec2 hash( vec2 p ) {
    p = vec2( dot(p,vec2(127.1,311.7)),
    dot(p,vec2(269.5,183.3)) );

    return -1.0 + 2.0*fract(sin(p)*43758.5453123);
}

float noise( in vec2 p ){

    const float K1 = 0.366025404; // (sqrt(3)-1)/2;
    const float K2 = 0.211324865; // (3-sqrt(3))/6;

    vec2 i = floor( p + (p.x+p.y)*K1 );

    vec2 a = p - i + (i.x+i.y)*K2;
    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));
    vec2 b = a - o + K2;
    vec2 c = a - 1.0 + 2.0*K2;

    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );

    vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));

    return dot( n, vec3(70.0) );
}

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

// -----------------------------------------------
void main(){

    vec2 uv = vUv;

    uv *= 2.0;
    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );
    float r  = 0.5000*noise( uv ); uv = m*uv;
    r += 0.5500*noise( uv ); uv = m*uv;
    //f += 0.1250*noise( uv ); uv = m*uv;
    //f += 0.0625*noise( uv ); uv = m*uv;
    m = mat2( 1.5,  1.2, -1.5,  1.6 );
    float g  = 0.8000*noise( uv ); uv = m*uv;
    m = mat2( 0.6,  2.2, 1.2,  2.1 );
    float b  = 0.5000*noise( uv ); uv = m*uv;
    b += 0.3800*noise( uv ); uv = m*uv;


    //r *= smoothstep( 0.0, 0.005, abs(p.x-0.6) );

    r = rand( uv + rand_c ) - 0.5;
    g = rand( uv + hash( rand_c ) ) - 0.5;
    b = rand( uv + rand( rand_c ) ) - 0.5;

    //r = vUv.x;
    //g = fract( vUv.y * 16.0 );
    //b = 1.0 - vUv.x;


    gl_FragColor = vec4( r * 0.5, g * 0.5, b * 0.5, 1.0 );
    if (mode>0.0) gl_FragColor = vec4( r, r, r, 1.0 );
}
</script>

<script id="fragmentShader_display" type="x-shader/x-fragment">
precision highp float;
precision highp int;
uniform vec2 resolution;
uniform sampler2D texture;
varying vec2 vUv;
void main()	{
    vec3 adapted = texture2D( texture, vUv ).xyz + vec3( 0.5 );
    gl_FragColor = vec4( adapted, 1.0 );
}
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
precision highp float;
precision highp int;
uniform vec2 resolution;
uniform sampler2D texture;
varying vec2 vUv;
void main()	{
    gl_FragColor = texture2D( texture, vUv );
}
</script>

<script id="fragmentShader_copy" type="x-shader/x-fragment">
precision highp float;
precision highp int;
uniform sampler2D texture;
varying vec2 vUv;
void main()	{
    gl_FragColor = texture2D( texture, vUv );
}
</script>

<script>

    if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
    var container, stats;
    //var camera=[], scene=[],
    var renderer, controls;
    //var uniforms = [],
    var textures = [], layers = [];
    //var weightsTexture, copy_weightsTexture, bufferTexture, outputTexture;
    var firstRun = true;
    //var train = false;
    var net;


    var options = options || {};
    var learning_rate = typeof options.learning_rate !== 'undefined' ? options.learning_rate : 0.01;
    var l1_decay = typeof options.l1_decay !== 'undefined' ? options.l1_decay : 0.0;
    var l2_decay = typeof options.l2_decay !== 'undefined' ? options.l2_decay : 0.001;
    var batch_size = typeof options.batch_size !== 'undefined' ? options.batch_size : 1;
    var method = typeof options.method !== 'undefined' ? options.method : 'sgd'; // sgd/adagrad/adadelta/windowgrad/netsterov

    var momentum = typeof options.momentum !== 'undefined' ? options.momentum : 0.9;
    var ro = typeof options.ro !== 'undefined' ? options.ro : 0.95; // used in adadelta
    var eps = typeof options.eps !== 'undefined' ? options.eps : 1e-6; // used in adadelta

    var k = 0; // iteration counter
    var gsum = []; // last iteration gradients (used for momentum calculations)
    var xsum = []; // used in adadelta


    var cost_loss = 0.0;
    var l2_decay_loss = 0.0;
    var l1_decay_loss = 0.0;

    function loadTextures( callback ){

        textures[0] = new THREE.TextureLoader().load("../textures/sunflower.jpg", function(){
            //textures[0] = new THREE.TextureLoader().load("aaa.png", function(){

            textures[1] = new THREE.TextureLoader().load("noise3x24.png", function(){

                textures[1].minFilter = THREE.NearestFilter;
                textures[1].magFilter = THREE.NearestFilter;

                textures[2] = new THREE.TextureLoader().load("../textures/andro.png", function(){

                    textures[0].format = THREE.RGBAFormat;
                    textures[0].type = THREE.FloatType;
                    textures[0].generateMipmaps = true;
                    textures[0].needsUpdate = true;

                    callback();
                });
            });
        });
    }

    init();

    function init(){

        container = document.getElementById( 'container' );

        renderer = new THREE.WebGLRenderer(
                //{alpha: true}
                { preserveDrawingBuffer: true }
        );
        renderer.setSize( 128*7, 128*30 );
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);
        renderer.autoClear = false;
        renderer.autoClearColor = false;
        // renderer.autoClearDepth = false;
        //renderer.autoClearStencil = false;
        renderer.clear();

        renderer.context.getExtension('EXT_shader_texture_lod');

        onWindowResize();
        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('keydown', onDocumentKeyDown, false);

        loadTextures( createNet );

    }

    function createNet() {


        //  ConvLayer = function( id, renderer, sx, Nfilters, input_layer, stride, pad, noise_texture )
        layers.push( new ConvLayer( 0, renderer, 3, 8, undefined, 1, 0, false ) );

        //layers.push( new ConvLayer( 1, renderer, 3, 3, layers[0], 1, 0, false ) );
        layers.push( new PoolLayer( 1, renderer, 2, layers[0], 2, 0 ) );

        layers.push( new ConvLayer( 2, renderer, 3, 20, layers[1], 1, 0, false ) );

        layers.push( new PoolLayer( 3, renderer, 2, layers[2], 2, 0 ) );

        layers.push( new ConvLayer( 4, renderer, 3, 20, layers[3], 1, 0, false ) );

        layers.push( new PoolLayer( 5, renderer, 2, layers[4], 2, 0 ) );

        layers.push( new ConvLayer( 6, renderer, 3, 40, layers[5], 1, 0, false ) );

        layers.push( new PoolLayer( 7, renderer, 2, layers[6], 2, 0 ) );

        ///var FCLayer = function( id, renderer, out_depth, input_layer )
        layers.push( new FCLayer( 8, renderer, 10, layers[7] ) );

        layers.push( new RegressionLayer( 3, renderer, layers[8] ) );


        layers[0].setInputTexture( textures[0], 128 );

        for (var i=0; i< layers.length; i++) {

            layers[i].init();

        }

    }

    //function train() {

        // initialize lists for accumulators. Will only be done once on first iteration
//        if(this.gsum.length === 0 && (this.method !== 'sgd' || this.momentum > 0.0)) {
//            // only vanilla sgd doesnt need either lists
//            // momentum needs gsum
//            // adagrad needs gsum
//            // adadelta needs gsum and xsum
//            for(var i=0;i<pglist.length;i++) {
//                this.gsum.push(global.zeros(pglist[i].params.length));
//                if(this.method === 'adadelta') {
//                    this.xsum.push(global.zeros(pglist[i].params.length));
//                } else {
//                    this.xsum.push([]); // conserve memory
//                }
//            }
//        }

   // }



    function onDocumentKeyDown( event ) {

        console.log( event.keyCode );

        switch( event.keyCode ) {

            case 49:  // '1' key

                    for (var i=0; i< layers.length; i++) {

                        layers[i].forward();

                    }

                layers[layers.length-1].backward();

                break;

            case 50:   // 2

                for (var i=layers.length - 2; i >= 0; i--) {

                    layers[i].backward();
                    layers[i].updateFilter();

                }

                break;

            case 13:   // Enter

                trainStartTime = Date.now();
                animate();


                break;

            case 27:   // ESC

                cancelAnimationFrame(id);

                break;
        }
    }

    var loss = { x:1, y:1, z:1 }; var limit = 0.001;
    var iter = 0;

    var fps = 60;
    var now;
    var then = Date.now();
    var interval = 1000/fps;
    var delta;
    var id;
    var trainStartTime, trainEndTime;

    function animate() {



        id = requestAnimationFrame( animate );

        now = Date.now();
        delta = now - then;

        if (delta > interval) {

            then = now - (delta % interval);

            train();
        }
    }

    function train() {

        //if ( loss.x > limit || loss.y > limit || loss.z > limit ) {
        if ( loss.x > limit ) {

            for (var i=0; i< layers.length; i++) {

                layers[i].forward();

            }

            loss = layers[layers.length-1].backward();

            for (var i=layers.length - 2; i >= 0; i--) {

                layers[i].backward();
                layers[i].updateFilter();

            }

            iter++;

        } else {

            cancelAnimationFrame(id);

            trainEndTime = Date.now();

        }

        console.log('iterations: ', iter);
        console.log('train time: ', ( trainEndTime - trainStartTime ) );

    }




    function onWindowResize( event ) {
        //renderer.setSize( window.innerWidth, window.innerHeight );
        //uniforms.resolution.value.x = 512;
        //uniforms.resolution.value.y = 512;
    }

</script>

</body>
</html>