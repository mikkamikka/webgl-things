<!DOCTYPE html>
<html lang="en">
<head>
    <title>ascii</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #000;
            color: #fff;
            margin: 0px;
            overflow: hidden;
        }
        #info {
            color: #fff;
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display:block;
        }
        #info a, .button { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
    </style>
</head>

<body>

<script src="js/three.min.js"></script>
<script src="js/stats.min.js"></script>
<script src="js/OBJLoader.js"></script>

<script type="x-shader/x-vertex" id="vertexShader">
    varying vec2 vUv;

    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }
</script>

<script type="x-shader/x-vertex" id="fragmentShader">
    varying vec2 vUv;

    uniform float mode;
    uniform float rx;
    uniform float ry;
    uniform float charMapSize;
    uniform float numChars;
    uniform sampler2D inputTexture;
    uniform sampler2D asciiTexture;
    uniform sampler2D hashTexture;
    uniform vec2 fontSize;
    vec2 imageSize = vec2(500.0, 500.0);
    vec2 canvasSize = vec2(500.0, 500.0);

    const float contrast = 0.0;
    const float colorDepth = 255.0/16.0;
    const vec2 hashSize = vec2(256.0, 256.0);

    vec4 pix = vec4(0.0, 0.0, 0.0, 0.0);
    vec4 key = vec4(0.0, 0.0, 0.0, 0.0);

    float h_fs_x, h_fs_y;

    float packColor(vec4 color) {
        return (color.r + (color.g*256.0) + (color.b*256.0*256.0) + (color.a*256.0*256.0*256.0));
    }

    vec4 contrastPix(float _x, float _y) {
        float factor = (259.0 * (contrast + 255.0)) / (255.0 * (259.0 - contrast));
        vec4 p = texture2D(inputTexture, vec2(_x, _y));
        p.r = (factor * ((p.r*255.0) - 128.0) + 128.0)/255.0;
        p.g = (factor * ((p.g*255.0) - 128.0) + 128.0)/255.0;
        p.b = (factor * ((p.b*255.0) - 128.0) + 128.0)/255.0;
        p.a = 1.0;

        return p;
    }

    void sampleRegion(float x, float y) {
        vec4 c1, c2, c3, c4;

        c1 = contrastPix(x, y);
        key.r += (c1.r + c1.g + c1.b)/3.0;

        c2 = contrastPix(x+h_fs_x, y);
        key.g += (c2.r + c2.g + c2.b)/3.0;

        c3 = contrastPix(x, y+h_fs_y);
        key.b += (c3.r + c3.g + c3.b)/3.0;

        c4 = contrastPix(x+h_fs_x, y+h_fs_y);
        key.a += (c4.r + c4.g + c4.b)/3.0;

        c1.r = (floor((c1.r*255.0)/colorDepth)*colorDepth)/255.0;
        c1.g = (floor((c1.g*255.0)/colorDepth)*colorDepth)/255.0;
        c1.b = (floor((c1.b*255.0)/colorDepth)*colorDepth)/255.0;
        pix.rgb += c1.rgb;
    }

    void analyseQuads(vec2 _offset) {
        h_fs_x = (fontSize.x*0.5)/imageSize.x;
        h_fs_y = (fontSize.y*0.5)/imageSize.y;

        float increment = 1.0/imageSize.y;
        float y=_offset.y;
        float x=_offset.x;

        sampleRegion(x, y); x+=increment;
        sampleRegion(x, y); x+=increment;
        sampleRegion(x, y); x+=increment;
        sampleRegion(x, y); x+=increment;
        x=_offset.x; y+=increment;

        sampleRegion(x, y); x+=increment;
        sampleRegion(x, y); x+=increment;
        sampleRegion(x, y); x+=increment;
        sampleRegion(x, y); x+=increment;
        x=_offset.x; y+=increment;

        sampleRegion(x, y); x+=increment;
        sampleRegion(x, y); x+=increment;
        sampleRegion(x, y); x+=increment;
        sampleRegion(x, y); x+=increment;
        x=_offset.x; y+=increment;

        sampleRegion(x, y); x+=increment;
        sampleRegion(x, y); x+=increment;
        sampleRegion(x, y); x+=increment;
        sampleRegion(x, y); x+=increment;
        x=_offset.x; y+=increment;

        pix /= 16.0;
        key = floor(key)/16.0;
    }

    void main(void) {

        imageSize.x = rx;
        canvasSize.x = rx;
        imageSize.y = ry;
        canvasSize.y = ry;

        ivec2 ioffset = ivec2(gl_FragCoord.xy/fontSize.xy);
        ioffset *= ivec2(fontSize.xy);
        vec2 offset = vec2(ioffset);
        offset /= canvasSize;

        analyseQuads(offset);
        float index = packColor( key )/256.0;
        float hash_x = mod(index, hashSize.x);
        float hash_y = (index-hash_x)/hashSize.x;

        vec4 char_pix = texture2D(hashTexture, vec2(hash_x/256.0, hash_y/256.0));
        float ch = floor((char_pix.g)*255.0);

        vec2 pos = mod(gl_FragCoord.xy, fontSize.xy);
        pos = pos / vec2(fontSize.x*numChars, fontSize.y);
        pos.x += ((floor(ch)*fontSize.x)/charMapSize);
        pos.y = 1.0 - pos.y;

        vec4 ascii_pix = vec4(texture2D(asciiTexture, pos).rgb, 1.0);


        if(ascii_pix.r > 0.0 || mode!=6.0) {
            if(mode==5.0) ascii_pix.rgb = pix.rgb;
            else if(mode==1.0) ascii_pix.rgb = vec3(pix.g*0.1*ascii_pix.r, pix.g*ascii_pix.g, pix.g*0.1*ascii_pix.b);
            else if(mode==2.0) ascii_pix.rgb = vec3(1.0-ascii_pix.r,1.0-ascii_pix.g,1.0-ascii_pix.b);
            else if(mode==3.0) ascii_pix.rgb = vec3(1.0-pix.r*ascii_pix.r,1.0-pix.g*ascii_pix.g,1.0-pix.b*ascii_pix.b);
            else if(mode==4.0) ascii_pix.rgb = vec3(1.0-char_pix.g*ascii_pix.r, 1.0-char_pix.g*ascii_pix.g, 1.0-char_pix.g*ascii_pix.b);
            else if(mode==7.0) ascii_pix.rgb = vec3(pix.g*50.0/255.0*ascii_pix.r, pix.g*161.0/255.0*ascii_pix.g, pix.g*199.0/255.0*ascii_pix.b);
            else if(mode==8.0) ascii_pix.rgb = vec3(pix.r*ascii_pix.r, pix.g*ascii_pix.g*offset.x, pix.b*ascii_pix.b*offset.y);
            else if(mode==9.0) ascii_pix.rgb = vec3(1.0-pix.r*ascii_pix.r*offset.x, 1.0-pix.g*ascii_pix.g*offset.x, 1.0-pix.b*ascii_pix.b*offset.y);
            else if(mode==0.0) ascii_pix.rgb = vec3(pix.r*ascii_pix.r, pix.g*ascii_pix.g,pix.b*ascii_pix.b);
        }

        gl_FragColor = ascii_pix;
         //gl_FragColor = texture2D(asciiTexture, vUv);
    }
</script>

<script>
    var container;
    var camera, scene, material, renderer;
    var screenCamera, screenScene, screenQuad, screenMaterial, rtTexture;
    var mouseX = 0, mouseY = 0;
    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;

    var alphabetTexture;
    var fontWidth = 10;
    var fontHeight = 14;
    var uniforms;
    var alphabetCanvas;
    var dpr = 1;
    var charNum = 128;
    var renderWindow = {width: window.innerWidth, height: window.innerHeight};
    var asciiMode = 0;

    init();

    function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        stats = new Stats();
        container.appendChild( stats.dom );

        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
        camera.position.z = 250;
        // scene
        scene = new THREE.Scene();
        var ambient = new THREE.AmbientLight( 0x555555 );
        scene.add( ambient );
        var directionalLight = new THREE.DirectionalLight( 0xffeedd );
        directionalLight.position.set( 0, 0, 1 );
        scene.add( directionalLight );

        // texture
        var manager = new THREE.LoadingManager();
        manager.onProgress = function ( item, loaded, total ) {
            console.log( item, loaded, total );
        };
        var onProgress = function ( xhr ) {
            if ( xhr.lengthComputable ) {
                var percentComplete = xhr.loaded / xhr.total * 100;
                console.log( Math.round(percentComplete, 2) + '% downloaded' );
            }
        };
        var onError = function ( xhr ) {
        };

        material = new THREE.MeshPhongMaterial({ color: 0x6677aa });

        // model
        var loader = new THREE.OBJLoader( manager );
        loader.load( 'model/male02.obj', function ( object ) {
            object.traverse( function ( child ) {
                if ( child instanceof THREE.Mesh ) {
                    child.material = material;
                }
            } );
            object.position.y = - 95;
            scene.add( object );

            animate();

        }, onProgress, onError );

        rtTexture = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight );

        screenScene = new THREE.Scene();
        screenCamera = new THREE.OrthographicCamera( window.innerWidth / -2,
                window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 0, 10000 );
        //screenCamera.position.z = 100;


        initPostprocessing();

        screenMaterial = new THREE.ShaderMaterial({
            uniforms: {
                inputTexture: {type: 't', value: rtTexture.texture},
                asciiTexture: {type: 't', value: alphabetTexture},
                hashTexture: {type: 't', value: THREE.ImageUtils.loadTexture("fontHash.png")}, //
                mode: {type: 'f', value: asciiMode},
                numChars: {type: 'f', value: charNum},
                rx: {type: 'f', value: window.innerWidth},
                ry: {type: 'f', value: window.innerHeight},
                charMapSize: {type: 'f', value: charNum * fontWidth},
                fontSize: {type: 'v2', value: new THREE.Vector2(fontWidth, fontHeight)}

            },
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent
            //side: THREE.DoubleSide
        });

        screenQuad = new THREE.Mesh( new THREE.PlaneBufferGeometry(window.innerWidth, window.innerHeight),
        screenMaterial );
        //screenQuad.scale.x = window.innerWidth;
        //screenQuad.scale.y = window.innerHeight;
        //screenQuad.position.z = -100;

        screenScene.add( screenQuad );



        //
        renderer = new THREE.WebGLRenderer();
        //renderer.setClearColor(0x111111);
        //renderer.autoClear = false;
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );
        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        //
        window.addEventListener( 'resize', onWindowResize, false );
    }

    function initPostprocessing() {

        var image = new Image(), texture = new THREE.Texture(image);
        var hash = document.createElement("canvas");
        hash.style.opacity = 0;
        image.onload = function () {
            texture.needsUpdate = true;
        };
        image.src = hash.toDataURL();

        var alphabetImage = new Image();
        alphabetCanvas = document.createElement('canvas');
        alphabetCanvas.setAttribute("id", "alphabetCanvas");

        alphabetTexture = new THREE.Texture(alphabetCanvas);
        alphabetTexture.needsUpdate = true;
        alphabetTexture.minFilter = THREE.NearestFilter;

        updateAlphabet();

    }

    function updateAlphabet(string) {
        if (!string || string === "")
            string = '.\'`^",:;Il!i~+_-?][}{1)(/tfjrxnuvczmwqpdbkhaoXYUJCLQ0OZ#MW&8%B@$';
        alphabetCanvas.width = charNum * fontWidth * dpr;
        alphabetCanvas.height = fontHeight * dpr;
        var ctx = alphabetCanvas.getContext("2d");
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, alphabetCanvas.width, alphabetCanvas.height);
        ctx.fillStyle = "#FFFFFF";
        ctx.shadowColor = '#FFFFFF';
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.shadowBlur = 3 * dpr;
        ctx.font = fontHeight * 1.0 * dpr + "px Courier";
        ctx.scale(1, -1);
        ctx.textAlign = 'center';
        for (var i = 0; i < charNum; i++) {
            var id = Math.floor(string.length * (1 - (i + 1) / (charNum)));
            var letter = string.substr(id, 1);
            for (var j = 0; j < 3; j++) {
                ctx.fillText(letter, (0.5 + i * fontWidth + fontWidth / 2 - 0.5) * dpr, -2.5 * dpr);
            }
        }
        alphabetTexture.needsUpdate = true;

    }

    function onWindowResize() {

        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();


        screenCamera.left = - windowHalfX;
        screenCamera.right = windowHalfX;
        screenCamera.top = windowHalfY;
        screenCamera.bottom = - windowHalfY;
        screenCamera.updateProjectionMatrix();

        //screenQuad.scale.x = window.innerWidth;
        //screenQuad.scale.y = window.innerHeight;

        //rtTexture.setSize( window.innerWidth, window.innerHeight );

        rtTexture.dispose();

        rtTexture = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight );
        screenMaterial.uniforms.inputTexture.value = rtTexture.texture;
        screenMaterial.uniforms.rx.value = window.innerWidth;
        screenMaterial.uniforms.ry.value = window.innerHeight;

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function onDocumentMouseMove( event ) {
        mouseX = ( event.clientX - windowHalfX ) / 2;
        mouseY = ( event.clientY - windowHalfY ) / 2;
    }

    //
    function animate() {
        requestAnimationFrame( animate );
        render();
        stats.update();
    }

    function render() {

        camera.position.x += ( mouseX - camera.position.x ) * .15;
        camera.position.y += ( - mouseY - camera.position.y ) * .15;
        camera.lookAt( scene.position );

        var size = (0.2 + 0.8 * window.innerHeight / 600 / 4) * 1.5;
        if (size < .5)
            size = .5;

//        if (selected != -1 && !MOBILE_VERSION) {
//            size *= 1.3;
//        }
//
//        if (MOBILE_VERSION) {
//            size *= 1.5;
//        }
        //screenMaterial.uniforms[ 'fontSize'].value = new THREE.Vector2(Math.floor(size * fontWidth), Math.floor(size * fontHeight));
        //screenMaterial.uniforms[ 'charMapSize'].value = charNum * Math.floor(fontWidth * size);


        renderer.render( scene, camera, rtTexture );

        renderer.render( screenScene, screenCamera );

        //renderer.render( scene, camera );
    }
</script>

</body>
</html>